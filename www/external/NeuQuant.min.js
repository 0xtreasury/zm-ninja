// NeuQuant.js
// ===========

/*
 * NeuQuant Neural-Net Quantization Algorithm
 * ------------------------------------------
 *
 * Copyright (c) 1994 Anthony Dekker
 *
 * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See
 * "Kohonen neural networks for optimal colour quantization" in "Network:
 * Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of
 * the algorithm.
 *
 * Any party obtaining a copy of these files from the author, directly or
 * indirectly, is granted, free of charge, a full and unrestricted irrevocable,
 * world-wide, paid up, royalty-free, nonexclusive right and license to deal in
 * this software and documentation files (the "Software"), including without
 * limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons who
 * receive copies from any such party to do so, with the only requirement being
 * that this copyright notice remain intact.
 */

/*
 * This class handles Neural-Net quantization algorithm
 * @author Kevin Weiner (original Java version - kweiner@fmsware.com)
 * @author Thibault Imbert (AS3 version - bytearray.org)
 * @version 0.1 AS3 implementation
 * @version 0.2 JS->AS3 "translation" by antimatter15
 * @version 0.3 JS clean up + using modern JS idioms by sole - http://soledadpenades.com
 * Also implement fix in color conversion described at http://stackoverflow.com/questions/16371712/neuquant-js-javascript-color-quantization-hidden-bug-in-js-conversion
 */

NeuQuant=function(){function r(){function r(r,n,f){var o,t
for(y=r,p=n,h=f,s=new Array(w),o=0;o<w;o++)s[o]=new Array(4),t=s[o],t[0]=t[1]=t[2]=(o<<d+8)/w|0,R[o]=k/w|0,P[o]=0}function n(){for(var r=[],n=new Array(w),f=0;f<w;f++)n[s[f][3]]=f
for(var o=0,t=0;t<w;t++){var a=n[t]
r[o++]=s[a][0],r[o++]=s[a][1],r[o++]=s[a][2]}return r}function f(){var r,n,f,o,t,a,u,c
for(u=0,c=0,r=0;r<w;r++){for(t=s[r],f=r,o=t[1],n=r+1;n<w;n++)a=s[n],a[1]<o&&(f=n,o=a[1])
if(a=s[f],r!=f&&(n=a[0],a[0]=t[0],t[0]=n,n=a[1],a[1]=t[1],t[1]=n,n=a[2],a[2]=t[2],t[2]=n,n=a[3],a[3]=t[3],t[3]=n),o!=u){for(O[u]=c+r>>1,n=u+1;n<o;n++)O[n]=r
u=o,c=r}}for(O[u]=c+b>>1,n=u+1;n<256;n++)O[n]=b}function o(){var r,n,f,o,t,a,u,s,w,b,j,k,q,x
for(p<Q&&(h=1),e=30+(h-1)/3,k=y,q=0,x=p,j=p/(3*h),b=j/g|0,s=I,a=F,u=a>>D,u<=1&&(u=0),r=0;r<u;r++)S[r]=s*((u*u-r*r)*K/(u*u))
for(w=p<Q?3:p%A!==0?3*A:p%l!==0?3*l:p%m!==0?3*m:3*N,r=0;r<j;)if(f=(255&k[q+0])<<d,o=(255&k[q+1])<<d,t=(255&k[q+2])<<d,n=v(f,o,t),i(s,n,f,o,t),0!==u&&c(u,n,f,o,t),q+=w,q>=x&&(q-=p),r++,0===b&&(b=1),r%b===0)for(s-=s/e,a-=a/G,u=a>>D,u<=1&&(u=0),n=0;n<u;n++)S[n]=s*((u*u-n*n)*K/(u*u))}function t(r,n,f){var o,t,a,u,c,i,v
for(c=1e3,v=-1,o=O[n],t=o-1;o<w||t>=0;)o<w&&(i=s[o],a=i[1]-n,a>=c?o=w:(o++,a<0&&(a=-a),u=i[0]-r,u<0&&(u=-u),a+=u,a<c&&(u=i[2]-f,u<0&&(u=-u),a+=u,a<c&&(c=a,v=i[3])))),t>=0&&(i=s[t],a=n-i[1],a>=c?t=-1:(t--,a<0&&(a=-a),u=i[0]-r,u<0&&(u=-u),a+=u,a<c&&(u=i[2]-f,u<0&&(u=-u),a+=u,a<c&&(c=a,v=i[3]))))
return v}function a(){return o(),u(),f(),n()}function u(){var r
for(r=0;r<w;r++)s[r][0]>>=d,s[r][1]>>=d,s[r][2]>>=d,s[r][3]=r}function c(r,n,f,o,t){var a,u,c,i,v,e,y
for(c=n-r,c<-1&&(c=-1),i=n+r,i>w&&(i=w),a=n+1,u=n-1,e=1;a<i||u>c;){if(v=S[e++],a<i){y=s[a++]
try{y[0]-=v*(y[0]-f)/M|0,y[1]-=v*(y[1]-o)/M|0,y[2]-=v*(y[2]-t)/M|0}catch(r){}}if(u>c){y=s[u--]
try{y[0]-=v*(y[0]-f)/M|0,y[1]-=v*(y[1]-o)/M|0,y[2]-=v*(y[2]-t)/M|0}catch(r){}}}}function i(r,n,f,o,t){var a=s[n],u=r/I
a[0]-=u*(a[0]-f)|0,a[1]-=u*(a[1]-o)|0,a[2]-=u*(a[2]-t)|0}function v(r,n,f){var o,t,a,u,c,i,v,e,y,p
for(e=~(1<<31),y=e,i=-1,v=i,o=0;o<w;o++)p=s[o],t=p[0]-r,t<0&&(t=-t),a=p[1]-n,a<0&&(a=-a),t+=a,a=p[2]-f,a<0&&(a=-a),t+=a,t<e&&(e=t,i=o),u=t-(P[o]>>j-d),u<y&&(y=u,v=o),c=R[o]>>x,R[o]-=c,P[o]+=c<<q
return R[i]+=z,P[i]-=B,v}var e,y,p,h,s,w=256,A=499,l=491,m=487,N=503,Q=3*N,b=w-1,d=4,g=100,j=16,k=1<<j,q=10,x=10,z=k>>x,B=k<<q-x,C=w>>3,D=6,E=1<<D,F=C*E,G=30,H=10,I=1<<H,J=8,K=1<<J,L=H+J,M=1<<L,O=[],P=[],R=[],S=[]
r.apply(this,arguments)
var T={}
return T.map=t,T.process=a,T}return r}()
